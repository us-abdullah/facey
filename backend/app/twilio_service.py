"""Twilio SMS + voice call alerting for restricted-zone violations."""

import logging
import os
from urllib.parse import quote

logger = logging.getLogger(__name__)

# ── Defaults ──────────────────────────────────────────────────────────────
DEFAULT_ALERT_TO = "+17326948445"
DEFAULT_MESSAGING_SERVICE_SID = "MGbeabe48cb26d252c506513ebe01f22b9"
ZONE_ALERT_BODY = "Intruder detected! check dashboard in analyst area"


def send_zone_alert_sms(
    zone_name: str,
    alert_type: str,
    person_name: str,
    details: str,
) -> bool:
    """Send an SMS via Twilio when an unauthorized person is in a restricted zone.

    Reads TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN from env.  Optionally reads
    TWILIO_ALERT_TO and TWILIO_MESSAGING_SERVICE_SID to override the defaults.

    Returns True on success, False otherwise.
    """
    account_sid = os.environ.get("TWILIO_ACCOUNT_SID", "")
    auth_token = os.environ.get("TWILIO_AUTH_TOKEN", "")

    if not account_sid or not auth_token:
        logger.warning("TWILIO_ACCOUNT_SID / TWILIO_AUTH_TOKEN not set – skipping SMS")
        return False

    to_number = os.environ.get("TWILIO_ALERT_TO", DEFAULT_ALERT_TO)
    messaging_service_sid = os.environ.get(
        "TWILIO_MESSAGING_SERVICE_SID", DEFAULT_MESSAGING_SERVICE_SID
    )

    try:
        from twilio.rest import Client

        client = Client(account_sid, auth_token)
        message = client.messages.create(
            body=ZONE_ALERT_BODY,
            to=to_number,
            messaging_service_sid=messaging_service_sid,
        )
        logger.info(
            "Twilio SMS sent (sid=%s) for zone=%s person=%s",
            message.sid,
            zone_name,
            person_name,
        )
        return True
    except Exception:
        logger.exception(
            "Failed to send Twilio SMS for zone=%s person=%s",
            zone_name,
            person_name,
        )
        return False


def send_escalation_sms(
    escalation_level: str,
    sms_body: str,
    zone_name: str,
    person_name: str,
) -> bool:
    """Send an escalated SMS crafted by the Nemotron Super threat escalation agent.

    Only called for unknown (unregistered) persons.
    The sms_body is generated by Nemotron Super 49B based on the threat analysis.
    """
    account_sid = os.environ.get("TWILIO_ACCOUNT_SID", "")
    auth_token = os.environ.get("TWILIO_AUTH_TOKEN", "")

    if not account_sid or not auth_token:
        logger.warning("TWILIO creds not set – skipping escalation SMS")
        return False

    to_number = os.environ.get("TWILIO_ALERT_TO", DEFAULT_ALERT_TO)
    messaging_service_sid = os.environ.get(
        "TWILIO_MESSAGING_SERVICE_SID", DEFAULT_MESSAGING_SERVICE_SID
    )

    body = sms_body.strip() if sms_body else (
        f"[{escalation_level}] Unknown intruder in {zone_name}. Check dashboard."
    )

    try:
        from twilio.rest import Client

        client = Client(account_sid, auth_token)
        message = client.messages.create(
            body=body,
            to=to_number,
            messaging_service_sid=messaging_service_sid,
        )
        logger.info(
            "Escalation SMS sent (sid=%s) level=%s zone=%s",
            message.sid,
            escalation_level,
            zone_name,
        )
        return True
    except Exception:
        logger.exception(
            "Failed to send escalation SMS level=%s zone=%s",
            escalation_level,
            zone_name,
        )
        return False


def send_escalation_voice_call(
    escalation_level: str,
    zone_name: str,
    person_name: str,
    reasoning: str = "",
) -> bool:
    """Place a voice call via Twilio that reads the escalation alert aloud.

    Uses Twilio's built-in <Say> TwiML with a TwiML Bin-style inline URL.
    Only called alongside send_escalation_sms for unknown persons.

    Returns True on success, False otherwise.
    """
    account_sid = os.environ.get("TWILIO_ACCOUNT_SID", "")
    auth_token = os.environ.get("TWILIO_AUTH_TOKEN", "")

    if not account_sid or not auth_token:
        logger.warning("TWILIO creds not set – skipping escalation voice call")
        return False

    to_number = os.environ.get("TWILIO_ALERT_TO", DEFAULT_ALERT_TO)

    # Build the spoken message
    subject = "an unregistered individual" if person_name.lower() == "unknown" else person_name
    spoken = (
        f"HOF Capital Security Alert. {escalation_level} level. "
        f"{subject} detected in {zone_name}. "
    )
    if reasoning:
        spoken += f"{reasoning} "
    spoken += "Please check the security dashboard immediately."

    # Use inline TwiML via the `twiml` parameter (no hosted URL needed)
    twiml = (
        f'<Response>'
        f'<Say voice="Polly.Joanna" language="en-US">{spoken}</Say>'
        f'<Pause length="1"/>'
        f'<Say voice="Polly.Joanna" language="en-US">Repeating. {spoken}</Say>'
        f'</Response>'
    )

    try:
        from twilio.rest import Client

        client = Client(account_sid, auth_token)

        # Get a Twilio phone number from the account to use as caller ID
        from_number = os.environ.get("TWILIO_FROM_NUMBER", "")
        if not from_number:
            # Use the messaging service's phone number or first available number
            try:
                numbers = client.incoming_phone_numbers.list(limit=1)
                if numbers:
                    from_number = numbers[0].phone_number
            except Exception:
                pass

        if not from_number:
            logger.warning("No TWILIO_FROM_NUMBER and no numbers on account – skipping call")
            return False

        call = client.calls.create(
            twiml=twiml,
            to=to_number,
            from_=from_number,
        )
        logger.info(
            "Escalation voice call placed (sid=%s) level=%s zone=%s to=%s",
            call.sid,
            escalation_level,
            zone_name,
            to_number,
        )
        return True
    except Exception:
        logger.exception(
            "Failed to place escalation voice call level=%s zone=%s",
            escalation_level,
            zone_name,
        )
        return False
